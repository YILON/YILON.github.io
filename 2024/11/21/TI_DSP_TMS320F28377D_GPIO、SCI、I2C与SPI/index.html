<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI | YILON</title><meta name="author" content="YILON"><meta name="copyright" content="YILON"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="GPIO 除了 CPU 控制的 I&#x2F;O 功能外，单个 GPIO 引脚可复用多达12个独立的外设信号。 每个引脚输出既可由外设控制，也可由四个master控制：  CPU1 CPU1.CLA CPU2 CPU2.CLA  最高有8个 IO 端口: • Port A ： GPIO0-GPIO31 • Port B ： GPIO32-GPIO63 • Port C ： GPIO64-GPIO95 • P">
<meta property="og:type" content="article">
<meta property="og:title" content="TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI">
<meta property="og:url" content="http://example.com/2024/11/21/TI_DSP_TMS320F28377D_GPIO%E3%80%81SCI%E3%80%81I2C%E4%B8%8ESPI/index.html">
<meta property="og:site_name" content="YILON">
<meta property="og:description" content="GPIO 除了 CPU 控制的 I&#x2F;O 功能外，单个 GPIO 引脚可复用多达12个独立的外设信号。 每个引脚输出既可由外设控制，也可由四个master控制：  CPU1 CPU1.CLA CPU2 CPU2.CLA  最高有8个 IO 端口: • Port A ： GPIO0-GPIO31 • Port B ： GPIO32-GPIO63 • Port C ： GPIO64-GPIO95 • P">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/private_img/cover.svg">
<meta property="article:published_time" content="2024-11-21T09:00:32.000Z">
<meta property="article:modified_time" content="2024-12-24T00:45:25.023Z">
<meta property="article:author" content="YILON">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="DSP">
<meta property="article:tag" content="TMS320F28377D">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/private_img/cover.svg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/11/21/TI_DSP_TMS320F28377D_GPIO%E3%80%81SCI%E3%80%81I2C%E4%B8%8ESPI/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #4582A0;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/private_img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/private_img/cover.svg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YILON</span></a><a class="nav-page-title" href="/"><span class="site-name">TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-21T09:00:32.000Z" title="发表于 2024-11-21 17:00:32">2024-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T00:45:25.023Z" title="更新于 2024-12-24 08:45:25">2024-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/DSP/">DSP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>GPIO</h1>
<p>除了 CPU 控制的 I/O 功能外，单个 GPIO 引脚可复用多达<code>12</code>个独立的外设信号。<br>
每个引脚输出既可由外设控制，也可由四个<code>master</code>控制：</p>
<ul>
<li>CPU1</li>
<li>CPU1.CLA</li>
<li>CPU2</li>
<li>CPU2.CLA</li>
</ul>
<p><kbd>最高</kbd>有8个 IO 端口:<br>
• Port A ： GPIO0-GPIO31<br>
• Port B ： GPIO32-GPIO63<br>
• Port C ： GPIO64-GPIO95<br>
• Port D ： GPIO96-GPIO127<br>
• Port E ： GPIO128-GPIO159<br>
• Port F ： GPIO160-GPIO191<br>
• Port G ： GPIO192-GPIO223<br>
• Port H ： GPIO224-GPIO255</p>
<p><img src="./GPIO%E5%BC%95%E8%84%9A%E9%80%BB%E8%BE%91%E6%A1%86%E5%9B%BE.png" alt="GPIO引脚逻辑框图"><br>
首先，输入和输出路径完全分开，只在引脚处连接。其次，外设复用远离引脚。<br>
因此，CPU 和 CLA 都可以读取引脚的物理状态，而不受master设置和外设复用的影响。<br>
同样的，外部中断也可以从外设活动中产生。<br>
开漏输出等所有引脚选项对所有主设备和外设都有效。</p>
<blockquote>
<p>注意，外设复用、master 设置和引脚配置<strong>只能由 CPU1 配置</strong>。</p>
</blockquote>
<h2 id="GPIO写入冲突">GPIO写入冲突</h2>
<p><code>GPyDAT</code>寄存器反映对应IO口当前的状态。<br>
当配置对应引脚为输出引脚时，对该寄存器写入可以改变引脚的电平。<br>
否则，对该寄存器写入的值会被寄存，直到引脚被配置为输出后，引脚电平才被驱动为写入值。</p>
<p>可见通过对<code>GPyDAT</code>寄存器的写入而改变引脚电平存在一个过程，<br>
或者说写入寄存器与驱动引脚之间存在延迟。</p>
<p>而软件写入<code>GPyDAT</code>寄存器的某一位的操作，<br>
实际上是先读取<code>GPyDAT</code>寄存器的值，然后将更改的位写入，再重新写回<code>GPyDAT</code>寄存器。</p>
<p>这就造成一个问题：<br>
当前一个指令对<code>GPyDAT</code>寄存器的某一位bit a进行写入，  下一个指令对<code>GPyDAT</code>寄存器的另一位bit b进行写入，<br>
此时由于写入与驱动的延迟，<br>
第二条指令读取的<code>GPyDAT</code>寄存器的bit a仍然是旧的值，<br>
第二条指令重新写回去后，把第一条指令写的值覆盖，</p>
<p>造成的结果是第一条指令更改bit a的操作无效了。</p>
<blockquote>
<p>为了避免这个问题，<br>
最好在连续更改<code>GPyDAT</code>寄存器的指令之间增加一些等待<code>NOP</code>。<br>
更好的做法是通过操作<code>GPySET</code>/<code>GPyCLEAR</code>/<code>GPyTOGGLE</code>来更改引脚的电平。</p>
</blockquote>
<h2 id="输入限定">输入限定</h2>
<h3 id="无同步（异步输入）">无同步（异步输入）</h3>
<p>该模式用于不需要输入同步或由外设执行同步的外设，<br>
例如通信端口 McBSP、SCI、SPI 和 I2C。</p>
<blockquote>
<p>在外设执行同步时使用输入同步可能会导致意想不到的结果。<br>
因此，用户必须确保 GPIO 引脚配置为异步。</p>
</blockquote>
<h3 id="仅同步到SYSCLKOUT">仅同步到SYSCLKOUT</h3>
<p>这是所有引脚在复位时的默认模式。<br>
在此模式下，输入信号仅与系统时钟（SYSCLKOUT）同步。<br>
由于输入信号是异步的，因此需要一个 SYSCLKOUT 延迟周期的延迟时间。</p>
<h3 id="使用采样窗口进行限定">使用采样窗口进行限定</h3>
<p><img src="./GPIO%E9%87%87%E6%A0%B7%E7%AA%97%E5%8F%A3%E9%99%90%E5%AE%9A.png" alt="GPIO采样窗口限定"></p>
<p>在此模式下，信号首先与系统时钟（SYSCLKOUT）同步，<br>
然后经过指定采样数的确认（维持不变），才认为输入发生变化。</p>
<p>需指定以下参数：</p>
<ol>
<li>通过GPxCTRL[QUALPRDn]指定采样频率</li>
</ol>
<p><img src="./GPIO%E9%87%87%E6%A0%B7%E7%AA%97%E5%8F%A3%E9%99%90%E5%AE%9A_%E6%8C%87%E5%AE%9A%E9%87%87%E6%A0%B7%E9%A2%91%E7%8E%87.png" alt="GPIO采样窗口限定_指定采样频率"></p>
<ol start="2">
<li>通过GPxQSEL1/2指定采样次数。可指定为<code>3</code>个或<code>6</code>个。</li>
</ol>
<p>由上两个参数可确定 <code>采样窗口的宽度 = 采样周期 × (采样次数 - 1)</code>,<br>
信号维持时间必须大于采样窗口宽度才认为是有效采样。</p>
<h2 id="中断">中断</h2>
<p><img src="./GPIO_%E4%B8%AD%E6%96%AD.png" alt="GPIO_中断"><br>
如图可见，为GPIO配置中断有两个步骤：</p>
<ol>
<li>启用中断本身，并配置触发逻辑（上/下降沿触发）。</li>
<li>通过选择输入 X-BAR 信号 4、5、6、13 和 14 的来源来设置 XINT1-5 GPIO 引脚。</li>
</ol>
<blockquote>
<p>可见，最多只有5个外部引脚中断。</p>
</blockquote>
<h2 id="引脚复用">引脚复用</h2>
<p><img src="./%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A81.png" alt="引脚复用1"></p>
<p><img src="./%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A82.png" alt="引脚复用2"></p>
<p><img src="./%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A83.png" alt="引脚复用3"></p>
<p><img src="./%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A84.png" alt="引脚复用4"></p>
<p><img src="./%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A85.png" alt="引脚复用5"></p>
<p><img src="./%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A86.png" alt="引脚复用6"></p>
<h2 id="引脚的内部上拉">引脚的内部上拉</h2>
<p>复位时，GPIO 处于输入模式，并禁用内部上拉。<br>
未驱动的输入可能会浮动到中间电压，并在输入缓冲器上造成浪费的击穿电流。<br>
用户必须始终将每个 GPIO 置于上述配置之一：</p>
<ul>
<li>输入模式，并由电路板上的另一个元件驱动至高于 Vih 或低于 Vil 的电平</li>
<li>输入模式，启用 GPIO 内部上拉</li>
<li>输出模式</li>
</ul>
<p>在引脚数较少的封装设备上，未绑定 GPIO 的上拉默认为启用，以防止浮动输入。<br>
用户必须注意避免在应用代码中禁用这些上拉。</p>
<p>在176PTP或100PZP封装上，必须启用任何内部未绑定 GPIO 的上拉，以防止浮动输入。<br>
TI 在 controlSUITE/C2000Ware 中提供了用户可以调用的功能，以启用任何未绑定 GPIO 的上拉。</p>
<p>该函数名为 GPIO_EnabledUnbondedIOPullups()、位于 (Device)_Sysctrl.c 文件中，<br>
默认情况下由 InitSysCtrl() 调用。</p>
<p>用户必须注意避免在应用代码中禁用这些上拉功能。</p>
<h2 id="应用">应用</h2>
<p>以使用Sysconfig工具自动配置的情况进行说明。</p>
<p>所有的IO配置都必须由CPU1 进行，并由CPU分配IO的控制权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//driverlib 关于GPIO常用接口函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能外部引脚中断</span></span><br><span class="line"><span class="comment">//! extIntNum parameter:</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_XINT1</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_XINT2</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_XINT3</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_XINT4</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_XINT5</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">GPIO_enableInterrupt</span><span class="params">(GPIO_ExternalIntNum extIntNum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消外部引脚中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">GPIO_disableInterrupt</span><span class="params">(GPIO_ExternalIntNum extIntNum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置中断触发逻辑</span></span><br><span class="line"><span class="comment">// intType</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_TYPE_FALLING_EDGE : 下降沿触发</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_TYPE_RISING_EDGE ： 上升沿触发</span></span><br><span class="line"><span class="comment">//! - GPIO_INT_TYPE_BOTH_EDGES  ： 两种边沿都可以触发</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">GPIO_setInterruptType</span><span class="params">(GPIO_ExternalIntNum extIntNum, GPIO_IntType intType)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取引脚电平</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">GPIO_readPin</span><span class="params">(<span class="type">uint32_t</span> pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置引脚电平</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">GPIO_writePin</span><span class="params">(<span class="type">uint32_t</span> pin, <span class="type">uint32_t</span> outVal)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转引脚电平</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">GPIO_togglePin</span><span class="params">(<span class="type">uint32_t</span> pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取端口电平</span></span><br><span class="line"><span class="comment">// typedef enum</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     GPIO_PORT_A = 0,                    //!&lt; GPIO port A</span></span><br><span class="line"><span class="comment">//     GPIO_PORT_B = 1,                    //!&lt; GPIO port B</span></span><br><span class="line"><span class="comment">//     GPIO_PORT_C = 2,                    //!&lt; GPIO port C</span></span><br><span class="line"><span class="comment">//     GPIO_PORT_D = 3,                    //!&lt; GPIO port D</span></span><br><span class="line"><span class="comment">//     GPIO_PORT_E = 4,                    //!&lt; GPIO port E</span></span><br><span class="line"><span class="comment">//     GPIO_PORT_F = 5                     //!&lt; GPIO port F</span></span><br><span class="line"><span class="comment">// &#125; GPIO_Port;</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">GPIO_readPortData</span><span class="params">(GPIO_Port port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写端口电平</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">GPIO_writePortData</span><span class="params">(GPIO_Port port, <span class="type">uint32_t</span> outVal)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>SCI</h1>
<ul>
<li>4个SCI：SCIA、SCIB、SCIC、SCID</li>
<li>可编程波特率 = <code>LSPCLK / ((BRR + 1) * 8 )</code><br>
当BRR = 0时，最大波特率为<code>LSPCLK/16</code><br>
注意BRR为16 bit无符号整数，因此并不能一定得到无误差的波特率</li>
</ul>
<blockquote>
<p>在Sysconfig中配置SCI模块波特率时是直接输入期望波特率，<br>
然后工具会自动计算接近的BRR值，因此要注意是否存在实际波特率和期望波特率偏差过大的情况。</p>
</blockquote>
<br>
<ul>
<li>数据格式
<ul>
<li>1起始位</li>
<li>可调的1~8数据位</li>
<li>可选的地址位（address mode）</li>
<li>可选的奇偶校验位</li>
<li>可调的1或2停止位</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>16级收/发FIFO，可设置FIFO内有多少数据（0~16）时触发中断<br>
8 bit宽的发送FIFO，10 bit宽的接收FIFO</li>
<li>自动波特率检测</li>
<li>四种错误检测标志：奇偶、overrun（覆盖写入）、framing(帧格式错误)、断线（传输线上超过9.625bit的持续低电平）</li>
<li>两种唤醒模式：
<ul>
<li>
<p>idle线：即数据线空闲时置高，<br>
直到检测到置低的起始位，适合一对一的情况</p>
</li>
<li>
<p>地址位：适合于多对多的情况。<br>
通话者发送的信息块的第一个字节为地址字节，所有监听者都能读取。<br>
（在数据块的第一个帧中，地址位被设置为 1，而在所有其他帧中，地址位被设置为 0）<br>
只有地址正确的监听者才接收后面的数据。<br>
<img src="./SCI%E5%94%A4%E9%86%92%E6%A8%A1%E5%BC%8F.png" alt="SCI唤醒模式"><br>
<img src="./SCI%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1.png" alt="SCI地址通信"></p>
</li>
</ul>
</li>
</ul>
<h2 id="应用-2">应用</h2>
<p>以使用Sysconfig工具自动配置的情况进行说明。<br>
CPU2要使用外设必须先由CPU1将外设控制权分配给CPU2.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在hw_memmap.h中定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCIA_BASE                 0x00007200U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCIB_BASE                 0x00007210U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCIC_BASE                 0x00007220U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCID_BASE                 0x00007230U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接收缓冲区是否有数据（不启用FIFO情况下）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">SCI_isDataAvailableNonFIFO</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断接收缓冲区是否有数据(不管有没有启用FIFO)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">SCI_getRxStatus</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断发送缓冲区是否有空位（不启用FIFO情况下）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">SCI_isSpaceAvailableNonFIFO</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取发送 FIFO 中的当前 word 的数量</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> SCI_TxFIFOLevel</span><br><span class="line"><span class="title function_">SCI_getTxFIFOStatus</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取接收 FIFO 中的当前 word 的数量</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> SCI_RxFIFOLevel</span><br><span class="line"><span class="title function_">SCI_getRxFIFOStatus</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在未启用 FIFO 的情况下，如果返回 false，</span></span><br><span class="line"><span class="comment">   则表示发送缓冲区和移位寄存器为空，发送器不忙。</span></span><br><span class="line"><span class="comment">   启用 FIFO 后，如果返回 false，则 FIFO 为空。 </span></span><br><span class="line"><span class="comment">   这并不一定意味着发送机不忙。 </span></span><br><span class="line"><span class="comment">   空的 FIFO 并不反映发送器移位寄存器的状态。</span></span><br><span class="line"><span class="comment">   当发送器仍在发送数据时，FIFO 可能为空。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">SCI_isTransmitterBusy</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞写入TxBuf</span></span><br><span class="line"><span class="comment">// 注意虽然data是16 bit， 但实际上只有低8位有效。  </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">SCI_writeCharBlockingNonFIFO</span><span class="params">(<span class="type">uint32_t</span> base, <span class="type">uint16_t</span> data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  不阻塞写入TxBuf</span></span><br><span class="line"><span class="comment">// 注意虽然data是16 bit， 但实际上只有低8位有效。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">SCI_writeCharNonBlocking</span><span class="params">(<span class="type">uint32_t</span> base, <span class="type">uint16_t</span> data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不阻塞读取RxBuf</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">SCI_readCharNonBlocking</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞读取Rxbuf</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">SCI_readCharBlockingNonFIFO</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞写入FIFO</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">SCI_writeCharBlockingFIFO</span><span class="params">(<span class="type">uint32_t</span> base, <span class="type">uint16_t</span> data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞从FIFO中读取</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span></span><br><span class="line"><span class="title function_">SCI_readCharBlockingFIFO</span><span class="params">(<span class="type">uint32_t</span> base)</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞，直到读到一个指定长度的数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SCI_readCharArray</span><span class="params">(<span class="type">uint32_t</span> base, <span class="type">uint16_t</span> * <span class="type">const</span> <span class="built_in">array</span>, <span class="type">uint16_t</span> length)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>I2C</h1>
<h2 id="I2C基本逻辑">I2C基本逻辑</h2>
<p>I2C是主从式半双工同步总线通信协议。<br>
物理层为两根总线：时钟线SCL、数据线SDA。<br>
总线通过电阻上拉，时钟线始终由主机驱动，不驱动数据线时设备IO呈高阻态。</p>
<p>7 bit寻址模式下理论最大支持2^7 - 1 = 127个从机，<br>
但实际会受到总线最大电容400pF的限制，实际一般不超过8个从机。</p>
<p>三种传输速率：</p>
<ul>
<li>标准模式：100 kbit/s</li>
<li>快速模式：400 kbit/s</li>
<li>高速模式：3.4Mbit/s</li>
</ul>
<p><img src="./I2C%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91.png" alt="I2C基本逻辑"></p>
<blockquote>
<p>SDA拉低为起始信号，SDA拉高为终止信号。 （皆由主机发出）<br>
7 bit寻址模式下，数据报文首帧(7 bit)是从机地址，其后跟着 1 bit的<code>读/写位</code>，1代表主-&gt;从，0代表从-&gt;主。<br>
10 bit寻址模式下，数据报文前两帧是从机地址。<br>
<img src="./I2C_7bit%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F.png" alt="I2C_7bit寻址模式"></p>
<p><img src="./I2C_10bit%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F.png" alt="I2C_10bit寻址模式"></p>
<p>在SCL高电平对SDA进行采样，在SCL低电平时对SDA进行变更。</p>
</blockquote>
<blockquote>
<p>I2C的机制决定了从机无法中止主机的读操作，<br>
因此要么主机事先知道要读多少数据，要么再封装一层协议从机告知主机停止通讯。</p>
</blockquote>
<h2 id="2837xD的I2C">2837xD的I2C</h2>
<ul>
<li>2个I2C：I2CA、I2CB</li>
<li>支持1~8 bit 的数据位</li>
<li>支持多个主发送机和从接收机</li>
<li>支持对各从发送机和主接收机</li>
<li>传输速率：10 Kbit/s ~ 400Kbit/s</li>
<li>16级 8bit宽 收发FIFO</li>
<li>中断触发信号：
<ul>
<li>I2Cx Interrupt：<br>
• Transmit-data ready<br>
• Receive-data ready<br>
• Register-access ready<br>
• No-acknowledgment received<br>
• Arbitration lost<br>
• Stop condition detected<br>
• Addressed as slave</li>
<li>FIFO_interrupt：（可设置FIFO内有多少数据（0~16）时触发中断）<br>
• Transmit FIFO interrupt<br>
• Receive FIFO interrupt</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>推荐总线上拉电阻为2.2KΩ</li>
</ul>
<br>
<ul>
<li>可调时钟占空比：
<ul>
<li>33%</li>
<li>55%</li>
</ul>
</li>
</ul>
<h2 id="基本工作方式">基本工作方式</h2>
<ul>
<li>两种发送模式：
<ul>
<li>标准模式：准确发送 n （n &gt; 0）个数据帧。必须由相应寄存器指定 n 。</li>
<li>重复模式：持续发送数据，直到使用软件触发 STOP 位或新的 START 位。</li>
</ul>
</li>
</ul>
<blockquote>
<p>I2C模块的时钟需要在7~12MHz之间。（这里不是指通信的时钟）<br>
当使用driverlib或SYSconfig时，不需要手动指定I2C模块的时钟。</p>
</blockquote>
<ul>
<li>自由数据格式：（无地址格式） （不支持回环模式）
<ul>
<li>适用于一对一通信时。注意要双方都支持。</li>
<li><img src="./I2C_%E8%87%AA%E7%94%B1%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="I2C_自由数据格式"></li>
</ul>
</li>
</ul>
<h2 id="多主机仲裁">多主机仲裁</h2>
<p>如果两个或两个以上的主发送器试图在大致相同的时间内在同一总线上开始传输，<br>
则会调用仲裁程序。<br>
仲裁程序使用竞争发送器在串行数据总线 (SDA) 上提供的数据。</p>
<p><img src="./I2C_%E5%A4%9A%E4%B8%BB%E6%9C%BA%E4%BB%B2%E8%A3%81.png" alt="I2C_多主机仲裁"></p>
<p>第一个将 SDA 线释放为高电平的主发送器被另一个将 SDA 驱动为低电平的主发送器否决。<br>
仲裁程序优先考虑传输二进制值最低的串行数据流的设备。<br>
如果两台或多台设备发送的第一个字节相同，则继续对后续字节进行仲裁。</p>
<p>如果 I2C 模块是丢失的主站，<br>
则 I2C 模块会切换到从接收器模式，设置仲裁丢失 (ARBL) 标志，<br>
并产生仲裁丢失中断请求。</p>
<p>如果在串行传输过程中，<br>
当向 SDA 发送重复的 START 位 或 STOP位时，<br>
仲裁程序仍在进行，<br>
则相关的主发送器必须在格式帧的相同位置发送重复的 START 位 或 STOP 位。</p>
<p>在以下情况之间不允许进行仲裁：<br>
• 重复的 START 位和一个数据位<br>
• 一个 STOP 位和一个数据位<br>
• 重复启动位和停止位</p>
<h1>SPI</h1>
<blockquote>
<p>时刻要注意普通SPI是主从式全双工同步通信协议，每发 1 bit就读取1 bit，<br>
因此收、发都要实现时，尤其是收发有意义的数据数量不相等时，<br>
要考虑再封装一层命令协议。</p>
</blockquote>
<ul>
<li>最多3个SPI：SPIA、SPIB、SPIC</li>
<li>支持更改片选引脚<code>SPISTE</code>的有效电平（默认为低电平有效）</li>
<li>支持3-wire SPI（即只有一根数据线，半双工通信）</li>
<li>可设的发送位宽：1~16 bit</li>
<li>四种时钟模式：<br>
<img src="./SPI%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F.png" alt="SPI时钟模式"></li>
</ul>
<br>
<ul>
<li>125种可编程速率<br>
<img src="./SPI%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%BE%E7%BD%AE.png" alt="SPI波特率设置"><br>
当取LSPCLK = SYSCLK = 200MHz时，可设置最大SPI波特率为50MHz（需要使用特定引脚）。</li>
</ul>
<br>
<ul>
<li>收/发缓冲区为16 bit</li>
<li>16级16bit的收/发FIFO，可设置FIFO内有多少数据（0~16）时触发中断<code>TXFFIL/RXFFIL</code></li>
</ul>
<br>
<ul>
<li>支持DMA（必须开启FIFO）
<ul>
<li>
<p>DMA的 <code>Burst &lt; 16- TXFFIL/RXFFIL</code>，但是实测Burst &gt; 16时会出现错误</p>
</li>
<li>
<p>注意DMA读/写的地址必须处于DMA模块挂载的总线上</p>
</li>
<li>
<p>通过设定的FIFO触发中断<code>TXFFIL/RXFFIL</code>来触发DMA，比如想要FIFO为空时触发DMA，就取TXFFIL/RXFFIL = 0</p>
</li>
<li>
<p>当发送使用DMA时，即DMA往FIFO写数据，<br>
此时<code>Destination Address Transfer Step</code>和<code>Destination Address Burst Step</code>都要设为 0；</p>
</li>
<li>
<p>当发送使用DMA时，即DMA往FIFO读数据，<br>
此时<code>Source Address Transfer Step</code>和<code>Source Address Burst Step</code>都要设为 0；</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于设备作为SPI主机发送的场景，<br>
一种方案是将<code>one shot Mode</code>设置为一个触发信号发送一个burst，<br>
将<code>Continuous Mode</code>设置为每次发送完一个transfer关闭DMA通道。<br>
并将FIFO的中断触发等级设定为FIFO为空时触发（即FIFO为空时触发DMA）。<br>
这样每当准备好需要的发送的数据后，开启DMA通道，当FIFO为空时便自动将数据发送出去。</p>
</blockquote>
<h2 id="SPI高速模式">SPI高速模式</h2>
<p>根据datasheet中的要求：<br>
<img src="./SPI_%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%AB%98%E9%80%9F%E6%A8%A1%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%94%B5%E5%B9%B3%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4.png" alt="SPI_普通模式和高速模式对应电平建立时间"></p>
<p>不管是高速模式还是普通模式，最大时钟频率都能设置为<code>LSPCLK/4</code>。<br>
当<code>LSPCLK = SYSCLK = 200MHz</code>时，<br>
此设备的SPI便能达到最大的<code>50MHz</code>，<br>
对应一个时钟周期为<code>20ns</code>。<br>
而上图中可以看到，普通模式下，SOMI有效建立时间最小都是20ns，<br>
显然无法达到50MHz的需求。<br>
（实际应用中普通模式下15MHz还是能正常工作的，更高就未测试过了）</p>
<p>因此对于时钟频率很高的应用中，最好还是开启高速模式。</p>
<p>但注意只有一些IO支持high speed mode：<br>
<img src="./%E6%94%AF%E6%8C%81%E9%AB%98%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%9A%84SPI%E5%BC%95%E8%84%9A.png" alt="支持高速模式的SPI引脚"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="YILON">YILON</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/21/TI_DSP_TMS320F28377D_GPIO%E3%80%81SCI%E3%80%81I2C%E4%B8%8ESPI/">http://example.com/2024/11/21/TI_DSP_TMS320F28377D_GPIO%E3%80%81SCI%E3%80%81I2C%E4%B8%8ESPI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">YILON</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/DSP/">DSP</a><a class="post-meta__tags" href="/tags/TMS320F28377D/">TMS320F28377D</a></div><div class="post-share"><div class="social-share" data-image="/private_img/cover.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/21/TI_DSP_TMS320F28377D_DMA/" title="TI_DSP_TMS320F28377D_DMA"><img class="cover" src="/private_img/cover.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TI_DSP_TMS320F28377D_DMA</div></div><div class="info-2"><div class="info-item-1">概述  六个具有独立 PIE 中断的通道 每个 DMA 通道可由多个外设触发源独立触发 数据源和目标：  GSx RAM CPU 消息RAM (IPC RAM) ADC存储器总线映射结果寄存器 ePWMx SPI, McBSP, EMIF   字长:16-bit或 32-bit(SPI和 McBSP 限制为 16-bit) 吞吐量：4 cycles/word 无仲裁    DMA总线由32位地址总线、32位数据读总线、32位数据写总线组成。   明确一点，挂载在DMA总线上的内部存储空间只有GS RAM和MSG RAM， 因此DMA可以访问的内部空间指针（地址）必须分配在这两类空间中。 一般地，如果使用数组作为源或目标地址， 可使用如下方式将该数组分配在GS RAM或MSG RAM中：   首先在CMD文件中定义相应的段； 注意，CPU2要使用GS RAM或MSG RAM，必须先在CPU1中进行分配。 具体分配方式见文末例程。  1234567// 在数组定义之前声明// 假设定义的段的名字是“ramgs0”，代表其占用RAM GS0的空间。 #pragma...</div></div></div></a><a class="pagination-related" href="/2024/11/29/Qt5%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="Qt5相关注意事项"><img class="cover" src="/private_img/cover.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Qt5相关注意事项</div></div><div class="info-2"><div class="info-item-1">本文基于Qt5最后一个可离线安装的5.14.2版本。 Qt Creator与MSVC编译器 Qt Creator要使用MSVC编译器必须要安装VS或相应的MSVC工具包。 一个注意点是，Qt 5.14.2最高只支持MSVC 2017版本的编译器， 因此在安装VS 2022 或更高版本的安装工具中， 需要手动添加MSVC 2017 或 MSVC 2017的套件。 并且此时Qt 默认检测到的仍是最新版的MSVC的， 需要手动配置构建套件（Kit）。 打开Qt，选择上方工具栏的工具-&gt;选项， 在弹出来的窗口中选择Kits -&gt; 编译器， 如果有，点击右侧的添加-&gt;MSVC-&gt;C++，否则点击右侧的添加-&gt;Custom-&gt;C++， 在新建的栏目中如下配置： （初始化文件的路径在VS的安装目录下，如下是默认安装路径的情况）   然后点击构建套件(Kits)， 选择Destop Qt 5.14.2 MSVC2017 64bit（或者32 bit）， 在 compiler 中选择刚刚新建的编译器配置， 点击保存即可。 此时要求使用 windows...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/19/TI_DSP_C2000_driverlib%E4%B8%8ESysconfig/" title="TI_DSP_C2000_driverlib与Sysconfig"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-19</div><div class="info-item-2">TI_DSP_C2000_driverlib与Sysconfig</div></div><div class="info-2"><div class="info-item-1">driverlib 简述 driverLib是德州仪器为C2000微控制器提供的一个驱动库，它包含了大量的硬件抽象层（HAL）函数，用于简化微控制器的编程过程。 driverlib 库的代码组织通常遵循模块化设计，每个模块对应一个微控制器外设或功能模块。 每个模块都提供初始化函数、配置函数以及操作函数。开发者只需调用这些函数即可完成外设的配置和操作，避免手动处理低级别的寄存器操作。 由于 driverlib 提供了对硬件寄存器的抽象层，代码在不同的 C2000 器件之间的移植变得更容易。  TI通常将项目架构称为基于bit-filed的或基于driverlib的， 前者即所谓的“操作寄存器”式设计，是C2000Ware/device_support中的例程形式。   driverlib包含在C2000 Ware中，要使用此库，必须安装C2000 Ware。  driverlib的文件结构 默认位置安装C2000...</div></div></div></a><a class="pagination-related" href="/2024/12/13/TI_DSP_TMS320F28377D_IPC/" title="TI_DSP_TMS320F28377D_IPC"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-13</div><div class="info-item-2">TI_DSP_TMS320F28377D_IPC</div></div><div class="info-2"><div class="info-item-1">基本架构  功能组成 Message RAMs 有两个 2KByte 的消息RAM， 分别为由CPU1 -&gt; CPU2 和 CPU2 -&gt; CPU1。 具体控制情况如下：   对Message RAM进行读写不会触发远程CPU的任何事件。  IPC 标志和中断 每个通信方向有 32 个IPC事件信号。  CPUx 可以通过写入 IPCSET 寄存器 32 位中的任意一位来引发 IPC 事件。 这将设置 CPUx IPCFLG 寄存器和 CPUy IPCSTS 寄存器中的相应位。  CPUy 可以通过设置 IPCACK 寄存器中的相应位来发出响应事件的信号。 这将清除 CPUx IPCFLG 寄存器和 CPUy IPCSTS 寄存器中的相应位。  如果 CPUx 需要取消事件，可设置 IPCCLR 寄存器中的相应位。 这与 CPUy 写入 IPCACK 的效果相同。  标志 0-3（使用 IPCSET[3:0]设置）向远程 CPU 发射中断。 远程 CPU 必须正确配置 ePIE 模块才能接收 IPC 中断。 标志 4-31（使用 IPCSET[31:4]...</div></div></div></a><a class="pagination-related" href="/2024/10/21/TI_DSP_TMS320F28377D_DMA/" title="TI_DSP_TMS320F28377D_DMA"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-21</div><div class="info-item-2">TI_DSP_TMS320F28377D_DMA</div></div><div class="info-2"><div class="info-item-1">概述  六个具有独立 PIE 中断的通道 每个 DMA 通道可由多个外设触发源独立触发 数据源和目标：  GSx RAM CPU 消息RAM (IPC RAM) ADC存储器总线映射结果寄存器 ePWMx SPI, McBSP, EMIF   字长:16-bit或 32-bit(SPI和 McBSP 限制为 16-bit) 吞吐量：4 cycles/word 无仲裁    DMA总线由32位地址总线、32位数据读总线、32位数据写总线组成。   明确一点，挂载在DMA总线上的内部存储空间只有GS RAM和MSG RAM， 因此DMA可以访问的内部空间指针（地址）必须分配在这两类空间中。 一般地，如果使用数组作为源或目标地址， 可使用如下方式将该数组分配在GS RAM或MSG RAM中：   首先在CMD文件中定义相应的段； 注意，CPU2要使用GS RAM或MSG RAM，必须先在CPU1中进行分配。 具体分配方式见文末例程。  1234567// 在数组定义之前声明// 假设定义的段的名字是“ramgs0”，代表其占用RAM GS0的空间。 #pragma...</div></div></div></a><a class="pagination-related" href="/2024/12/16/TI_DSP_TMS320F28377D_EMIF/" title="TI_DSP_TMS320F28377D_EMIF"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-16</div><div class="info-item-2">TI_DSP_TMS320F28377D_EMIF</div></div><div class="info-2"><div class="info-item-1">相关概念   SRAM(Static Random-Access Memory)：这种存储器只要保持通电，里面储存的数据就可以恒常保持。 DRAM(Dynamic Random-Access Memory)：里面所储存的数据就需要周期性地刷新充电。功耗较SRAM要小；集成度比SRAM要高，因此价格更便宜。   SDRAM（Synchronous Dynamic Random Access Memory）是一种同步动态随机存取存储器。 SDRAM的“同步”指的是它的操作是与系统时钟同步的， 这意味着数据传输的时序受到系统时钟信号的控制，使得数据访问和处理更为高效。 主要特点：  同步时序：SDRAM的所有操作都与外部时钟信号同步，保证数据传输的准确性和一致性。 动态存储：和传统的静态RAM（SRAM）相比，SDRAM是动态的，需要定期刷新才能保持数据。否则，存储的数据会丢失。 高性能：SDRAM通过使用流水线技术（pipelining）来提高数据处理速度，通常具有更高的带宽和更低的延迟。 三级寻址：先选择Bank，再选择行地址，最后再选择列地址。   第一代SDRAM(SDR...</div></div></div></a><a class="pagination-related" href="/2024/09/26/TI_DSP_TMS320F28377D_%E4%B8%AD%E6%96%AD/" title="TI_DSP_TMS320F28377D_中断"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-26</div><div class="info-item-2">TI_DSP_TMS320F28377D_中断</div></div><div class="info-2"><div class="info-item-1">中断  外设中断 C28xCPU有14个外设中断线。其中两个（INT13和INT14）分别直接连接到CPU定时器Timer 1和Timer...</div></div></div></a><a class="pagination-related" href="/2024/10/21/TI_DSP_TMS320F28377D_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" title="TI_DSP_TMS320F28377D_存储系统"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-21</div><div class="info-item-2">TI_DSP_TMS320F28377D_存储系统</div></div><div class="info-2"><div class="info-item-1">RAM 对于2837xD，RAM可分为不同几部分：  RAM的分类 专用RAM 每个CPU子系统有四个专用的RAM，只有对应的CPU可以访问这些RAM：  M0、M1： D0、D1：是安全存储器，具有访问保护功能，可为其分别配置不同类型的访问保护。  Local Share RAM（LSx RAM） 只能由对应CPU及其CLA访问的RAM。 这些RAM都是安全存储器，具有访问保护功能，可为其分别配置不同类型的访问保护。 具有奇偶校验特性。 默认情况下，仅专用于CPU，CLA想要访问需要进行配置。 Global Share RAM（GSx RAM） 每个共享RAM可设置为由一CPU拥有，该CPU及其DMA对此RAM具有完全的读写访问权， 此时另一CPU只允许进行读取。 这些RAM是安全存储器，具有访问保护功能，可为其分别配置不同类型的访问保护。 每个GSx RAM模块的主机选择和访问保护配置可通过程序单独锁定， 此情况下一旦为其提交配置，在发出CPUx.SYSRS（复位）之间都不能更改配置。 只有CPU1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/private_img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YILON</div><div class="author-info-description">YILON的技术小窝</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YILON"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/YILON" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yilongdyx@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E5%86%99%E5%85%A5%E5%86%B2%E7%AA%81"><span class="toc-number">1.1.</span> <span class="toc-text">GPIO写入冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%99%90%E5%AE%9A"><span class="toc-number">1.2.</span> <span class="toc-text">输入限定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%EF%BC%88%E5%BC%82%E6%AD%A5%E8%BE%93%E5%85%A5%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">无同步（异步输入）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%85%E5%90%8C%E6%AD%A5%E5%88%B0SYSCLKOUT"><span class="toc-number">1.2.2.</span> <span class="toc-text">仅同步到SYSCLKOUT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%87%87%E6%A0%B7%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E9%99%90%E5%AE%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">使用采样窗口进行限定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.3.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">引脚复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%84%9A%E7%9A%84%E5%86%85%E9%83%A8%E4%B8%8A%E6%8B%89"><span class="toc-number">1.5.</span> <span class="toc-text">引脚的内部上拉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">SCI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-2"><span class="toc-number">2.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91"><span class="toc-number">3.1.</span> <span class="toc-text">I2C基本逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2837xD%E7%9A%84I2C"><span class="toc-number">3.2.</span> <span class="toc-text">2837xD的I2C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">基本工作方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%BB%E6%9C%BA%E4%BB%B2%E8%A3%81"><span class="toc-number">3.4.</span> <span class="toc-text">多主机仲裁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E9%AB%98%E9%80%9F%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">SPI高速模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/10/FPGA_RTL%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%8A%80%E5%B7%A7/" title="FPGA_RTL设计的注意事项与技巧.md"><img src="/private_img/cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FPGA_RTL设计的注意事项与技巧.md"/></a><div class="content"><a class="title" href="/2025/09/10/FPGA_RTL%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%8A%80%E5%B7%A7/" title="FPGA_RTL设计的注意事项与技巧.md">FPGA_RTL设计的注意事项与技巧.md</a><time datetime="2025-09-10T02:00:11.000Z" title="发表于 2025-09-10 10:00:11">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/16/TI_DSP_TMS320F2812_CAN/" title="TI_DSP_TMS320F2812_CAN"><img src="/private_img/cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TI_DSP_TMS320F2812_CAN"/></a><div class="content"><a class="title" href="/2025/05/16/TI_DSP_TMS320F2812_CAN/" title="TI_DSP_TMS320F2812_CAN">TI_DSP_TMS320F2812_CAN</a><time datetime="2025-05-16T01:38:37.000Z" title="发表于 2025-05-16 09:38:37">2025-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/26/FPGA_%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" title="FPGA_基本结构"><img src="/private_img/cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FPGA_基本结构"/></a><div class="content"><a class="title" href="/2024/12/26/FPGA_%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" title="FPGA_基本结构">FPGA_基本结构</a><time datetime="2024-12-26T01:33:15.000Z" title="发表于 2024-12-26 09:33:15">2024-12-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/private_img/Top.svg);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By YILON</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>