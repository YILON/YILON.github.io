<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TI_DSP_TMS320F28377D_DMA | YILON</title><meta name="author" content="YILON"><meta name="copyright" content="YILON"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="概述  六个具有独立 PIE 中断的通道 每个 DMA 通道可由多个外设触发源独立触发 数据源和目标：  GSx RAM CPU 消息RAM (IPC RAM) ADC存储器总线映射结果寄存器 ePWMx SPI, McBSP, EMIF   字长:16-bit或 32-bit(SPI和 McBSP 限制为 16-bit) 吞吐量：4 cycles&#x2F;word 无仲裁    DMA总线由32位地址总">
<meta property="og:type" content="article">
<meta property="og:title" content="TI_DSP_TMS320F28377D_DMA">
<meta property="og:url" content="http://example.com/2024/10/21/TI_DSP_TMS320F28377D_DMA/index.html">
<meta property="og:site_name" content="YILON">
<meta property="og:description" content="概述  六个具有独立 PIE 中断的通道 每个 DMA 通道可由多个外设触发源独立触发 数据源和目标：  GSx RAM CPU 消息RAM (IPC RAM) ADC存储器总线映射结果寄存器 ePWMx SPI, McBSP, EMIF   字长:16-bit或 32-bit(SPI和 McBSP 限制为 16-bit) 吞吐量：4 cycles&#x2F;word 无仲裁    DMA总线由32位地址总">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/private_img/cover.svg">
<meta property="article:published_time" content="2024-10-21T06:00:32.000Z">
<meta property="article:modified_time" content="2024-12-24T00:41:55.921Z">
<meta property="article:author" content="YILON">
<meta property="article:tag" content="DSP">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="TMS320F28377D">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/private_img/cover.svg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/21/TI_DSP_TMS320F28377D_DMA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TI_DSP_TMS320F28377D_DMA',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #4582A0;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/private_img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/private_img/cover.svg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YILON</span></a><a class="nav-page-title" href="/"><span class="site-name">TI_DSP_TMS320F28377D_DMA</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TI_DSP_TMS320F28377D_DMA</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-21T06:00:32.000Z" title="发表于 2024-10-21 14:00:32">2024-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T00:41:55.921Z" title="更新于 2024-12-24 08:41:55">2024-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/DSP/">DSP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>概述</h1>
<ul>
<li>六个具有独立 PIE 中断的通道</li>
<li>每个 DMA 通道可由多个外设触发源独立触发</li>
<li>数据源和目标：
<ul>
<li>GSx RAM</li>
<li>CPU 消息RAM (IPC RAM)</li>
<li>ADC存储器总线映射结果寄存器</li>
<li>ePWMx</li>
<li>SPI, McBSP, EMIF</li>
</ul>
</li>
<li>字长:16-bit或 32-bit(SPI和 McBSP 限制为 16-bit)</li>
<li>吞吐量：4 cycles/word 无仲裁</li>
</ul>
<p><img src="./F2837xD_DMA%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE.png" alt="F2837xD_DMA功能框图"></p>
<blockquote>
<p>DMA总线由<code>32位地址总线</code>、<code>32位数据读总线</code>、<code>32位数据写总线</code>组成。</p>
</blockquote>
<blockquote>
<p>明确一点，挂载在DMA总线上的内部存储空间只有GS RAM和MSG RAM，<br>
因此DMA可以访问的内部空间指针（地址）必须分配在这两类空间中。<br>
一般地，如果使用数组作为源或目标地址，<br>
可使用如下方式将该数组分配在GS RAM或MSG RAM中：</p>
</blockquote>
<blockquote>
<p>首先在CMD文件中定义相应的段；<br>
注意，CPU2要使用GS RAM或MSG RAM，必须先在CPU1中进行分配。<br>
具体分配方式见文末例程。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组定义之前声明</span></span><br><span class="line"><span class="comment">// 假设定义的段的名字是“ramgs0”，代表其占用RAM GS0的空间。 </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(arr_1,<span class="string">&quot;ramgs0&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组定义</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> arr_1[<span class="number">1024</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>外设挂载总线</h1>
<p>芯片的外设（单独或共同）挂载在两子系统的总线上，<br>
CPU、CLA、DMA可以通过数据总线访问外设。</p>
<p><img src="./%E5%A4%96%E8%AE%BE%E4%B8%8E%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF.png" alt="外设与内部总线"></p>
<blockquote>
<p>当CPU和DMA在同一周期访问相同的外设，则DMA具有优先级，且CPU处于停滞状态。</p>
</blockquote>
<p>通过配置<code>CPUSEL</code>中每个外设对应位来指定外设属于CPU1子系统还是CPU2子系统。<br>
决定好外设的归属后，<br>
在子系统的内部通过<code>SECCMSEL</code>配置第二主机（CLA或DMA）。</p>
<p>对于不属于本子系统的外设，<br>
CPU（及对应的CLA、DMA）对该外设的所有写操作都将被忽略，<br>
所有读操作都将返回<code>0x0</code>。</p>
<p>由于Arbiter（仲裁器）并不知道外设的归属，<br>
因此CPU子系统对外设的访问（不管其属不属于自己）都会触发仲裁器的仲裁逻辑。</p>
<h1>外设中断触发源</h1>
<p>每个 DMA 通道都可配置为由软件和其他外设触发事件触发。<br>
<code>DMACHSRCSELx</code> 寄存器用于配置每个 DMA 通道的 DMA 触发源。<br>
<code>CHx.MODE.PERINTSEL</code> 寄存器指定位域设置位所属通道的编号。</p>
<p><img src="./DMA%E8%A7%A6%E5%8F%91%E6%BA%90%E7%9A%84%E9%80%89%E6%8B%A9.png" alt="DMA触发源的选择"></p>
<p>这些 DMA 触发源包括五个外部中断信号，<br>
可连接到设备上的大多数通用输入/输出 (GPIO) 引脚。<br>
收到外设中断事件信号后，DMA 会自动向中断源发送清除信号，<br>
以便发生后续中断事件。</p>
<p>无论<code>MODE.CHx[PERINTSEL]</code> 位字段的值如何，<br>
软件始终可以通过 <code>CONTROL.CHx[PERINTFRC]</code> 位强制触发。<br>
同样，软件也可以使用 <code>CONTROL.CHx[PERINTCLR]</code> 位清除待处理的 DMA 触发信号。</p>
<p>一旦特定外设触发事件置位了通道的<code>PERINTFLG</code>位，<br>
该位将一直处于挂起状态，直到启动该通道的传输。<br>
一旦burst传输开始，标志位就会被清除。</p>
<blockquote>
<p>burst的定义可见下文。</p>
</blockquote>
<p>如果在传输过程中产生了新的外设触发事件，<br>
则相关burst会在响应新的外设触发事件（经过适当的优先级排序后）之前完成。</p>
<p>如果在待处理事件得到处理之前发生第三个外设触发事件，<br>
<code>CONTROL.CHx[OVRFLG]</code>位将置位表示溢出。</p>
<p>如果在清除锁存标志的同时发生外设触发事件，<br>
则触发事件具有优先权，<code>PERINTFLG</code> 保持置位。</p>
<p><img src="./%E5%A4%96%E8%AE%BE%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91DMA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="外设中断触发DMA示意图"></p>
<h1>DMA基本机制</h1>
<p>DMA 状态机最基本的功能是两个嵌套循环。</p>
<h2 id="Burst-Loop（Inner-Loop）">Burst Loop（Inner Loop）</h2>
<p>当一个 DMA 通道触发时，burst循环将开始传输。</p>
<blockquote>
<p><code>BURST_SIZE</code> 寄存器允许设置在一个脉冲串中传输<kbd>最多</kbd> 32 个 16 位字。</p>
</blockquote>
<blockquote>
<p>每个 DMA 通道都支持 16 位或 32 位字传输，（注意对应外设接口不一定支持）<br>
这由 <code>MODE.DATASIZE</code> 位字段控制。</p>
</blockquote>
<blockquote>
<p>一个Burst Loop传输的数据量由<code>BURST_SIZE</code>和<code>DataSize</code>共同决定：<br>
以下是不同的<code>BURST_SIZE</code>与<code>DataSize</code>取值组合时，16 bit字的传输数量：<br>
<img src="./DMA_Burst_Loop_%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%87%8F.png" alt="DMA_Burst_Loop_传输数据量"></p>
</blockquote>
<p>每个 DMA 通道都包含源地址和目标地址<br>
的影子地址指针<code> (SRC_ADDR_SHADOW与DST_ADDR_SHADOW）</code><br>
和活动地址指针<code>（SRC_ADDR_ACTIVE 与 DST_ADDR_ACTIVE）</code> 。</p>
<p>每次传输开始时，<br>
每个指针的影子版本都会被复制到各自的活动寄存器中。<br>
在burst循环期间，<br>
每个字传输完毕后，相应的活动寄存器迭代一个设置好的步长：</p>
<blockquote>
<p>SRC_ADDR_ACTIVE = SRC_ADDR_ACTIVE + SRC_BURST_STEP<br>
DST_ADDR_ACTIVE = DST_ADDR_ACTIVE + DST_BURST_STEP</p>
</blockquote>
<h2 id="Transfer-Loop（Outer-Loop）">Transfer Loop（Outer Loop）</h2>
<p>Transfer循环传输指定数量的burst，<br>
该数量由 <code>TRANSFER_SIZE + 1</code>设置。</p>
<p>由于 TRANSFER_SIZE 是一个 16 位寄存器，<br>
因此允许传输的总大小远远超出了任何实际要求。</p>
<blockquote>
<p>一次Transfer Loop，<br>
DMA传输量为<code>（Burst Loop传输数据量） x (TRANSFER_SIZE + 1)</code>个 16 bit字。</p>
</blockquote>
<p>在Transfer Loop过程中，每个burst完成后，有两种方法可用于迭代活动地址指针：</p>
<ul>
<li>
<p>禁用地址回环(Address Warpping)（默认）：<br>
（SRC_WRAP_SIZE 或 DST_WRAP_SIZE &gt; TRANSFER_SIZE）</p>
<blockquote>
<p>SRC_ADDR_ACTIVE = SRC_ADDR_ACTIVE + SRC_TRANSFER_STEP<br>
DST_ADDR_ACTIVE = DST_ADDR_ACTIVE + DST_TRANSFER_STEP</p>
</blockquote>
</li>
<li>
<p>启用地址回环(Address Warpping)<br>
当 SRC_WRAP_SIZE 或 DST_WRAP_SIZE &lt; TRANSFER_SIZE 时，<br>
将启用地址回环。<br>
此时会有一个计数器<code>SRC_WRAP_COUNT / DST_WRAP_COUNT</code><br>
初始时将<code>SRC_WRAP_SIZE / DST_WRAP_SIZE</code>装载进<code>SRC_WRAP_COUNT / DST_WRAP_COUNT</code><br>
并开始传输。<br>
<br><br>
每次burst Loop完成时，<br>
如果<code>SRC_WRAP_COUNT / DST_WRAP_COUNT != 0</code> ，<br>
则<code>SRC_ADDR_ACTIVE / SRC_ADDR_ACTIVE</code>照常迭代，计数器减一；<br>
当<code>SRC_WRAP_COUNT / DST_WRAP_COUNT == 0</code>时，<br>
将按以下方式迭代活动地址指针：</p>
<blockquote>
<p>SRC_BEG_ADDR_ACTIVE = SRC_BEG_ADDR_ACTIVE + SRC_WRAP_STEP<br>
DST_BEG_ADDR_ACTIVE = DST_BEG_ADDR_ACTIVE + DST_WRAP_STEP<br>
SRC_ADDR_ACTIVE = SRC_BEG_ADDR_ACTIVE<br>
DST_ADDR_ACTIVE = DST_BEG_ADDR_ACTIVE</p>
</blockquote>
<p>然后重新装载计数器的值，继续如上传输，<br>
直到burst传输数等于TRANSFER_SIZE，传输结束。</p>
<blockquote>
<p>当取<code>SRC_WRAP_STEP / DST_WRAP_STEP</code>与<code>SRC_TRANSFER_STEP / DST_TRANSFER_STEP</code>极性相反时，<br>
每次计数器归零，活动地址指针都会回退到初始位置，<br>
从而实现地址的回环。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>完整机制可见下文的状态机流程图。</p>
</blockquote>
<blockquote>
<p>无论 DATASIZE 如何，<br>
STEP 寄存器中指定的值都是 16 位地址。<br>
因此，要递增一个 32 位地址，可以在这些寄存器中设置 2 的值。</p>
</blockquote>
<h2 id="OneShot-Mode">OneShot Mode</h2>
<p>默认不启用OneShot Mode。</p>
<p>禁用 OneShot 模式<code>（MODE.CHx[ONESHOT] = 0）</code>时，<br>
每次收到 DMA 通道触发，DMA 都会执行一次Burst Loop。<br>
本次Burst Loop完成后，<br>
状态机将转到优先级方案中的下一个待处理通道，<br>
即使刚刚完成的通道还有另一个触发器待处理。<br>
此时可防止任何单一通道垄断 DMA 总线。</p>
<p>启用OneShot 模式<code>（MODE.CHx[ONESHOT] = 1）</code>后，<br>
DMA 会在单个 DMA 通道触发器上执行完整个 Transfer Loop。<br>
使用该模式时要小心，<br>
因为这会造成一个触发器占用大部分 DMA 带宽的情况。</p>
<h2 id="Continuous-Mode">Continuous Mode</h2>
<p>默认不启用Continuous Mode。</p>
<p>当连续模式被禁用<code>（MODE.CHx[CONTINUOUS] = 0）</code>时，<br>
DMA 状态机会在Transfer Loop中的所有Burst完成后<code>（TRANSFER_COUNT = 0）</code>禁用通道。<br>
必须通过设置控制寄存器中的 RUN 位重新启用通道，才能在该通道上开始另一次传输。</p>
<p>启用连续模式<code>（MODE.CHx[CONTINUOUS] = 1）</code>后，<br>
即使Transfer Loop<code>（TRANSFER_COUNT = 0）</code>中的所有Burst都已完成，<br>
DMA 状态机仍会保持通道处于活动状态。</p>
<p>每个 DMA 通道都可以使用 <code>MODE.CHx[CHINTMODE]</code> 位<br>
在 DMA 传输开始或结束时触发 EPIE 中断。</p>
<h2 id="DMA状态机流程图">DMA状态机流程图</h2>
<p><img src="./DMA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="DMA流程图"></p>
<p>注：</p>
<blockquote>
<p>HALT 点表示通道在以下情况下停止运行：<br>
被高优先级通道 1 触发器中断、<br>
设置 HALT 命令、<br>
发出仿真停止命令且 FREE 位清零。</p>
</blockquote>
<h1>DMA流水线与吞吐量</h1>
<p>一般情况下DMA都是4级流水线（4个系统时钟执行一次传输）：<br>
<img src="./DMA_4%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="DMA_4级流水线"></p>
<p>例外是McBSP作为数据源时，在传输的读取部分期间，读取McBSP DRR寄存器会使DMA总线停顿一个周期：<br>
<img src="./DMA_4%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF_1%E8%AF%BB%E5%81%9C%E9%A1%BF.png" alt="DMA_4级流水线_1读停顿"></p>
<h1>总线访问仲裁</h1>
<p>通常情况下，DMA 活动独立于 CPU 和 CLA 活动。<br>
但是，当 DMA 和 CPU（或 CLA）试图同时访问同一个外设时，<br>
所有相同外设类型的实例都会相互冲突。</p>
<p><img src="./F2837xD_DMA%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE.png" alt="F2837xD_DMA功能框图"></p>
<p>如上图，SPI与McBSP使用同一个总线接口，<br>
因此当CPU与DMA分别访问McBSP与SPI时便会造成冲突。</p>
<p>但 ADC 结果寄存器是个例外，每个总线主控器的 ADC 结果寄存器都是重复的。<br>
中央处理器、DMA 和 CLA 都可以同时读取这些结果寄存器，<br>
任何主控器都不需要停滞或仲裁。</p>
<p>而其余情况发生冲突时需要进行仲裁。</p>
<p>DMA 传输包括四个阶段：</p>
<ul>
<li>发送源地址</li>
<li>读取源数据</li>
<li>发送目标地址</li>
<li>写入目标数据<br>
如果 CPU 在 DMA 传输过程中访问外设/内存导致冲突，<br>
CPU 就会停滞，直到当前 DMA 访问完成，而不是整个 DMA 传输完成。</li>
</ul>
<blockquote>
<p>对于外设总线接口访问，采用固定优先级仲裁：</p>
<ul>
<li>CLA/DMA写</li>
<li>CLA/DMA读</li>
<li>CPU写</li>
<li>CPU读</li>
</ul>
</blockquote>
<blockquote>
<p>对于GSxRAM / MSGRAM访问，采用循环仲裁机制，见“存储器”一节。</p>
</blockquote>
<blockquote>
<p>如果 CPU 正在执行 &quot;读-修改-写 &quot;操作，<br>
而 DMA 正在对同一位置执行 &quot;写 &quot;操作，<br>
那么如果该操作发生在 CPU 读和 CPU 写之间，DMA 写操作可能会丢失。<br>
因此要避免将 CPU 写入与 DMA 对相同位置的写入混在一起。</p>
</blockquote>
<h1>DMA通道仲裁</h1>
<p>在确定信道优先级时，有两种优先级方案：</p>
<ul>
<li>循环模式</li>
<li>通道 1 高优先级模式</li>
</ul>
<h2 id="循环模式">循环模式</h2>
<p>此时所有通道具有相同的优先级，且每个使能的通道以循环的方式给予控制权：<br>
CH1 -&gt; CH2 -&gt; CH3 -&gt; CH4 -&gt; CH5 -&gt; CH6 -&gt; CH1 -&gt; ···</p>
<p>在上述情况下，每个通道完成<kbd>本次Burst Loop</kbd>后，<br>
下一个通道就会得到服务。</p>
<p>用户可以指定每个通道的Burst大小。<br>
一旦 CH6（或最后一个启用的通道）完成服务，且没有其他通道待处理，<br>
轮循状态机就会进入空闲状态。</p>
<h2 id="通道-1-高优先级模式">通道 1 高优先级模式</h2>
<p>在该模式下，通道 1 优先于所有其他通道。<br>
通道 2 至 6 的优先级相同，每个启用的通道都以循环方式提供服务。</p>
<p>当其余通道正在传输时，中断触发了CH1 DMA通道，<br>
DMA当完成<kbd>本次流水线</kbd>，不管本次Burst是否完成都将暂停传输，<br>
转而先处理CH1的传输，直到CH1的Burst完成，再处理原来的通道。</p>
<p>在这种模式下，通道 1 通常用于 ADC，因为数据传输速率非常高。</p>
<blockquote>
<p>通道 1 上不能同时使用高优先级模式和 ONESHOT 模式。<br>
当通道 1 处于高优先级模式时，其他通道可以使用 ONESHOT 模式。</p>
</blockquote>
<h1>触发事件溢出检测</h1>
<p>当 DMA 接收到外设事件触发时，<br>
CONTROL 寄存器中的 PERINTFLG 位被置位，通道进入 DMA 状态机。<br>
当该通道的Burst开始时，PERINTFLG 会被清除。</p>
<p>但是，如果在 PERINTFLG 位被事件触发器置位和脉冲串开始清零之间，<br>
又有一个事件触发到达，则第二个触发将丢失。</p>
<p>这种情况下，CONTROL 寄存器中的 OVRFLG 位将被置位，</p>
<p>如果溢出中断被启用，则通道中断将被发送至 PIE 模块：<br>
<img src="./DMA_%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B.png" alt="DMA_溢出检测"></p>
<h1>基于Sysconfig使用DMA</h1>
<blockquote>
<p>为了更好协同配置，建议创建<code>系统项目</code>，<br>
此类项目可以链接各个核的项目，在烧写自动为各核心烧写对应项目的程序，<br>
且会把.syscfg文件融合起来。</p>
</blockquote>
<br>
<ol>
<li>打开CPU1的syscfg文件中的<code>SYSCTL</code>模块，<br>
在<code>Peripheral Frame Secondary Controller</code>栏目中为目标的Frame配置为DMA为<code>Secondary controller</code>；<br>
<img src="./Sysconfig_DMA%E9%85%8D%E7%BD%AE1.png" alt="Sysconfig_DMA配置1"></li>
</ol>
<br>
<ol start="2">
<li>对于要为CPU2分配GS RAM的情况（DMA能访问的内部RAM只有这两种），<br>
需要分别创建一个<code>MEMCFG</code>模块，<br>
在CPU1中此模块中<code>GSRAM Configuration</code>栏目中将指定GSRAM分配给CPU2；<br>
CPU2中的<code>MEMCFG</code>模块不用配置。</li>
</ol>
<br>
<ol start="3">
<li>对于RAM-&gt;RAM的DMA传输，直接创建一个DMA模块即可；<br>
对于外设与RAM之间的DMA传输，需要在对应外设模块中进行设置。</li>
</ol>
<p><strong>下面对SPI模块使用DMA从GS RAM中自动装载发送缓冲为例（SPI主机模式）</strong></p>
<br>
<ol start="4">
<li>新建一个SPI模块，配置相关参数，<br>
选择<code>启用中断</code>、<code>启用FIFO</code>和<code>启用为发送使用DMA</code>。<br>
使用SPI模块使用DMA必须启用FIFO，<br>
启用中断是为了配置DMA触发源。</li>
</ol>
<br>
<blockquote>
<p>对于CPU2使用外设，<br>
必须先在CPU1的<code>SYSCTL</code>模块的<code>CPU Select For Peripherals</code>栏目中<br>
将指定外设的控制权移交给CPU2，否则CPU2无法进行控制）</p>
</blockquote>
<br>
<ol start="5">
<li>对于<code>Transmit FIFO Interrupt Level</code>，<br>
可以选择<code>Transmit FIFO empty</code>，<br>
这样每次FIFO为空时都会触发一次DMA传输。<br>
当然根据需要也可以选择其它的。</li>
</ol>
<br>
<ol start="6">
<li>配置下面的<code>Tx DMA</code>栏目，如图：<br>
<img src="./Sysconfig_DMA%E9%85%8D%E7%BD%AE2.png" alt="Sysconfig_DMA配置2"><br>
<code>DMA通道</code>、<code>DMA中断</code>可以根据需要进行选择；<br>
由于本例的Burst长度为16，刚好为SPI FIFO的深度，<br>
因此这里<code>One-shot Configuration</code>选择为<code>One Burstper Trigger</code><br>
这样每次FIFO为空时，DMA自动填满FIFO。<br>
<br><br>
对于<code>Continuous Mode Configuration</code>，<br>
这里选择<code>当前transfer发送完成后停止DMA传输</code><br>
同时先<code>不启用通道</code>，<br>
这样可以控制发送的时机。<br>
<br><br>
<code>Destination Address Setup</code>（目标地址）保持默认即可；<br>
<code>Source Address Setup</code>中，源地址将在代码中进行指定，<br>
<code>Source Address Burst Step</code>与<code>Source Address Transfer Step</code>设置为1即可，<br>
（对于只发送一个Burst的需求，<code>Source Address Transfer Step</code>应设置为0）</li>
</ol>
<br>
<ol start="7">
<li>相关代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须把DMA要访问的内部空间地址分配在GS RAM或MSG RAM中</span></span><br><span class="line"><span class="comment">//全局变量，不然DMA无法寻址</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(DMA_sData_buf,<span class="string">&quot;ramgs0&quot;</span>);</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> DMA_sData_buf[<span class="number">512</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用以指示发送数组已满</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> DMA_sData_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//初始化部分省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DMA相关API函数声明都在dma.h</span></span><br><span class="line">    <span class="comment">//配置DMA源路径</span></span><br><span class="line">    DMA_configSourceAddress(mySPIB_TX_DMA_BASE, &amp;DMA_sData_buf); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    类似函数还有：</span></span><br><span class="line"><span class="comment">    //配置目标路径</span></span><br><span class="line"><span class="comment">    DMA_configDestAddress(uint32_t base, const void *destAddr);</span></span><br><span class="line"><span class="comment">    //配置源路径和目标路径</span></span><br><span class="line"><span class="comment">    DMA_configAddresses(uint32_t base, const void *destAddr, const void *srcAddr);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其余部分省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里选择了定时发送</span></span><br><span class="line">__interrupt <span class="type">void</span> <span class="title function_">INT_myCPUTIMER1_ISR</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时往DMA数组装填数据</span></span><br><span class="line">        DMA_sData_buf[DMA_sData_flag] = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">        DMA_sData_flag ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(DMA_sData_flag &gt;= <span class="number">512</span>)&#123;    <span class="comment">//发送缓冲区满</span></span><br><span class="line">            DMA_startChannel(mySPIB_TX_DMA_BASE);   <span class="comment">//启动发送</span></span><br><span class="line">            <span class="comment">//认为发送缓冲区清空</span></span><br><span class="line">            DMA_sData_flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里要注意SPI的通信速率问题，  </span></span><br><span class="line"><span class="comment">            定时器的定时周期不能小于整个DMA_sData_buf数组发送所需时间</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此外，这种通过DMA进行SPI发送的模式是连续的，  </span></span><br><span class="line"><span class="comment">            即SPI的片选引脚拉低后，直到整个transfer发送完，才会把片选引脚拉高</span></span><br><span class="line"><span class="comment">            因此还要注意数据接收方的承受能力</span></span><br><span class="line"><span class="comment">            */</span>      </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="YILON">YILON</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/21/TI_DSP_TMS320F28377D_DMA/">http://example.com/2024/10/21/TI_DSP_TMS320F28377D_DMA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">YILON</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DSP/">DSP</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/TMS320F28377D/">TMS320F28377D</a></div><div class="post-share"><div class="social-share" data-image="/private_img/cover.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/21/TI_DSP_TMS320F28377D_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" title="TI_DSP_TMS320F28377D_存储系统"><img class="cover" src="/private_img/cover.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TI_DSP_TMS320F28377D_存储系统</div></div><div class="info-2"><div class="info-item-1">RAM 对于2837xD，RAM可分为不同几部分：  RAM的分类 专用RAM 每个CPU子系统有四个专用的RAM，只有对应的CPU可以访问这些RAM：  M0、M1： D0、D1：是安全存储器，具有访问保护功能，可为其分别配置不同类型的访问保护。  Local Share RAM（LSx RAM） 只能由对应CPU及其CLA访问的RAM。 这些RAM都是安全存储器，具有访问保护功能，可为其分别配置不同类型的访问保护。 具有奇偶校验特性。 默认情况下，仅专用于CPU，CLA想要访问需要进行配置。 Global Share RAM（GSx RAM） 每个共享RAM可设置为由一CPU拥有，该CPU及其DMA对此RAM具有完全的读写访问权， 此时另一CPU只允许进行读取。 这些RAM是安全存储器，具有访问保护功能，可为其分别配置不同类型的访问保护。 每个GSx RAM模块的主机选择和访问保护配置可通过程序单独锁定， 此情况下一旦为其提交配置，在发出CPUx.SYSRS（复位）之间都不能更改配置。 只有CPU1...</div></div></div></a><a class="pagination-related" href="/2024/11/21/TI_DSP_TMS320F28377D_GPIO%E3%80%81SCI%E3%80%81I2C%E4%B8%8ESPI/" title="TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI"><img class="cover" src="/private_img/cover.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI</div></div><div class="info-2"><div class="info-item-1">GPIO 除了 CPU 控制的 I/O 功能外，单个 GPIO 引脚可复用多达12个独立的外设信号。 每个引脚输出既可由外设控制，也可由四个master控制：  CPU1 CPU1.CLA CPU2 CPU2.CLA  最高有8个 IO 端口: • Port A ： GPIO0-GPIO31 • Port B ： GPIO32-GPIO63 • Port C ： GPIO64-GPIO95 • Port D ： GPIO96-GPIO127 • Port E ： GPIO128-GPIO159 • Port F ： GPIO160-GPIO191 • Port G ： GPIO192-GPIO223 • Port H ： GPIO224-GPIO255  首先，输入和输出路径完全分开，只在引脚处连接。其次，外设复用远离引脚。 因此，CPU 和 CLA 都可以读取引脚的物理状态，而不受master设置和外设复用的影响。 同样的，外部中断也可以从外设活动中产生。 开漏输出等所有引脚选项对所有主设备和外设都有效。  注意，外设复用、master 设置和引脚配置只能由 CPU1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/19/TI_DSP_C2000_driverlib%E4%B8%8ESysconfig/" title="TI_DSP_C2000_driverlib与Sysconfig"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-19</div><div class="info-item-2">TI_DSP_C2000_driverlib与Sysconfig</div></div><div class="info-2"><div class="info-item-1">driverlib 简述 driverLib是德州仪器为C2000微控制器提供的一个驱动库，它包含了大量的硬件抽象层（HAL）函数，用于简化微控制器的编程过程。 driverlib 库的代码组织通常遵循模块化设计，每个模块对应一个微控制器外设或功能模块。 每个模块都提供初始化函数、配置函数以及操作函数。开发者只需调用这些函数即可完成外设的配置和操作，避免手动处理低级别的寄存器操作。 由于 driverlib 提供了对硬件寄存器的抽象层，代码在不同的 C2000 器件之间的移植变得更容易。  TI通常将项目架构称为基于bit-filed的或基于driverlib的， 前者即所谓的“操作寄存器”式设计，是C2000Ware/device_support中的例程形式。   driverlib包含在C2000 Ware中，要使用此库，必须安装C2000 Ware。  driverlib的文件结构 默认位置安装C2000...</div></div></div></a><a class="pagination-related" href="/2024/12/13/TI_DSP_TMS320F28377D_IPC/" title="TI_DSP_TMS320F28377D_IPC"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-13</div><div class="info-item-2">TI_DSP_TMS320F28377D_IPC</div></div><div class="info-2"><div class="info-item-1">基本架构  功能组成 Message RAMs 有两个 2KByte 的消息RAM， 分别为由CPU1 -&gt; CPU2 和 CPU2 -&gt; CPU1。 具体控制情况如下：   对Message RAM进行读写不会触发远程CPU的任何事件。  IPC 标志和中断 每个通信方向有 32 个IPC事件信号。  CPUx 可以通过写入 IPCSET 寄存器 32 位中的任意一位来引发 IPC 事件。 这将设置 CPUx IPCFLG 寄存器和 CPUy IPCSTS 寄存器中的相应位。  CPUy 可以通过设置 IPCACK 寄存器中的相应位来发出响应事件的信号。 这将清除 CPUx IPCFLG 寄存器和 CPUy IPCSTS 寄存器中的相应位。  如果 CPUx 需要取消事件，可设置 IPCCLR 寄存器中的相应位。 这与 CPUy 写入 IPCACK 的效果相同。  标志 0-3（使用 IPCSET[3:0]设置）向远程 CPU 发射中断。 远程 CPU 必须正确配置 ePIE 模块才能接收 IPC 中断。 标志 4-31（使用 IPCSET[31:4]...</div></div></div></a><a class="pagination-related" href="/2024/12/16/TI_DSP_TMS320F28377D_EMIF/" title="TI_DSP_TMS320F28377D_EMIF"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-16</div><div class="info-item-2">TI_DSP_TMS320F28377D_EMIF</div></div><div class="info-2"><div class="info-item-1">相关概念   SRAM(Static Random-Access Memory)：这种存储器只要保持通电，里面储存的数据就可以恒常保持。 DRAM(Dynamic Random-Access Memory)：里面所储存的数据就需要周期性地刷新充电。功耗较SRAM要小；集成度比SRAM要高，因此价格更便宜。   SDRAM（Synchronous Dynamic Random Access Memory）是一种同步动态随机存取存储器。 SDRAM的“同步”指的是它的操作是与系统时钟同步的， 这意味着数据传输的时序受到系统时钟信号的控制，使得数据访问和处理更为高效。 主要特点：  同步时序：SDRAM的所有操作都与外部时钟信号同步，保证数据传输的准确性和一致性。 动态存储：和传统的静态RAM（SRAM）相比，SDRAM是动态的，需要定期刷新才能保持数据。否则，存储的数据会丢失。 高性能：SDRAM通过使用流水线技术（pipelining）来提高数据处理速度，通常具有更高的带宽和更低的延迟。 三级寻址：先选择Bank，再选择行地址，最后再选择列地址。   第一代SDRAM(SDR...</div></div></div></a><a class="pagination-related" href="/2024/11/21/TI_DSP_TMS320F28377D_GPIO%E3%80%81SCI%E3%80%81I2C%E4%B8%8ESPI/" title="TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-21</div><div class="info-item-2">TI_DSP_TMS320F28377D_GPIO、SCI、I2C与SPI</div></div><div class="info-2"><div class="info-item-1">GPIO 除了 CPU 控制的 I/O 功能外，单个 GPIO 引脚可复用多达12个独立的外设信号。 每个引脚输出既可由外设控制，也可由四个master控制：  CPU1 CPU1.CLA CPU2 CPU2.CLA  最高有8个 IO 端口: • Port A ： GPIO0-GPIO31 • Port B ： GPIO32-GPIO63 • Port C ： GPIO64-GPIO95 • Port D ： GPIO96-GPIO127 • Port E ： GPIO128-GPIO159 • Port F ： GPIO160-GPIO191 • Port G ： GPIO192-GPIO223 • Port H ： GPIO224-GPIO255  首先，输入和输出路径完全分开，只在引脚处连接。其次，外设复用远离引脚。 因此，CPU 和 CLA 都可以读取引脚的物理状态，而不受master设置和外设复用的影响。 同样的，外部中断也可以从外设活动中产生。 开漏输出等所有引脚选项对所有主设备和外设都有效。  注意，外设复用、master 设置和引脚配置只能由 CPU1...</div></div></div></a><a class="pagination-related" href="/2024/09/26/TI_DSP_TMS320F28377D_%E4%B8%AD%E6%96%AD/" title="TI_DSP_TMS320F28377D_中断"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-26</div><div class="info-item-2">TI_DSP_TMS320F28377D_中断</div></div><div class="info-2"><div class="info-item-1">中断  外设中断 C28xCPU有14个外设中断线。其中两个（INT13和INT14）分别直接连接到CPU定时器Timer 1和Timer...</div></div></div></a><a class="pagination-related" href="/2024/09/25/TI_DSP_TMS320F28377D_%E5%A4%8D%E4%BD%8D%E6%9C%BA%E5%88%B6/" title="TI_DSP_TMS320F28377D_复位机制"><img class="cover" src="/private_img/cover.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">TI_DSP_TMS320F28377D_复位机制</div></div><div class="info-2"><div class="info-item-1">设备标识 器件识别寄存器提供有关器件类别，器件系列，版本，器件编号，引脚数，工作温度范围，封装类型，引脚数和器件验证状态的信息。 所有器件信息都是 DEV_CFG_REGS空间的一部分，只能由 CPU1子系统上运行的软件访间。 UIDREGS中提供256位唯一ID（UID）。256位分为以下寄存器：  UID_PSRAND0-5：192位伪随机数据 UID_UNIQUE：32位唯一数据，该寄存器中的值在具有相同PARTIDH的所有器件中将是唯一的 UID_CHECKSUM: 前两者 的 32 位 fletcher...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/private_img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YILON</div><div class="author-info-description">YILON的技术小窝</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YILON"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/YILON" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yilongdyx@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">外设挂载总线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">外设中断触发源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">DMA基本机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Burst-Loop%EF%BC%88Inner-Loop%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">Burst Loop（Inner Loop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transfer-Loop%EF%BC%88Outer-Loop%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Transfer Loop（Outer Loop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OneShot-Mode"><span class="toc-number">4.3.</span> <span class="toc-text">OneShot Mode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Continuous-Mode"><span class="toc-number">4.4.</span> <span class="toc-text">Continuous Mode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E7%8A%B6%E6%80%81%E6%9C%BA%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">4.5.</span> <span class="toc-text">DMA状态机流程图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">DMA流水线与吞吐量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">总线访问仲裁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">DMA通道仲裁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">循环模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93-1-%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">通道 1 高优先级模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">触发事件溢出检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">基于Sysconfig使用DMA</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/24/TI_DSP_C2000%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F/" title="TI_DSP_C2000计算加速"><img src="/private_img/cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TI_DSP_C2000计算加速"/></a><div class="content"><a class="title" href="/2024/12/24/TI_DSP_C2000%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F/" title="TI_DSP_C2000计算加速">TI_DSP_C2000计算加速</a><time datetime="2024-12-24T02:33:24.000Z" title="发表于 2024-12-24 10:33:24">2024-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/16/TI_DSP_TMS320F28377D_EMIF/" title="TI_DSP_TMS320F28377D_EMIF"><img src="/private_img/cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TI_DSP_TMS320F28377D_EMIF"/></a><div class="content"><a class="title" href="/2024/12/16/TI_DSP_TMS320F28377D_EMIF/" title="TI_DSP_TMS320F28377D_EMIF">TI_DSP_TMS320F28377D_EMIF</a><time datetime="2024-12-16T03:10:24.000Z" title="发表于 2024-12-16 11:10:24">2024-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/TI_DSP_TMS320F28377D_IPC/" title="TI_DSP_TMS320F28377D_IPC"><img src="/private_img/cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TI_DSP_TMS320F28377D_IPC"/></a><div class="content"><a class="title" href="/2024/12/13/TI_DSP_TMS320F28377D_IPC/" title="TI_DSP_TMS320F28377D_IPC">TI_DSP_TMS320F28377D_IPC</a><time datetime="2024-12-13T07:10:44.000Z" title="发表于 2024-12-13 15:10:44">2024-12-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/private_img/Top.svg);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By YILON</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>